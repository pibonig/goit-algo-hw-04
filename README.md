# hw 4

# Аналіз алгоритмів сортування

У цьому домашньому завданні було проведено порівняльний аналіз трьох алгоритмів сортування: сортування злиттям, сортування вставками та Timsort. Основною метою було емпірично перевірити теоретичні оцінки складності алгоритмів та продемонструвати, чому поєднання сортування злиттям і сортування вставками робить алгоритм Timsort більш ефективним.

## Опис алгоритмів

1. **Сортування злиттям** - алгоритм, який використовує підхід "розділяй та володарюй", розбиваючи масив на дві частини, сортує кожну з них рекурсивно та з'єднує результати. Теоретична складність: O(n log n).

2. **Сортування вставками** - простий алгоритм, який будує відсортований масив поступово, вставляючи елементи один за одним. Теоретична складність: O(n^2), але працює добре на малих масивах або майже відсортованих даних.

3. **Timsort** - гібридний алгоритм, який використовує поєднання сортування злиттям і сортування вставками. Цей алгоритм є вбудованим в Python і має теоретичну складність O(n log n) в середньому випадку. Він оптимізований для реальних наборів даних, часто працює краще завдяки поєднанню двох підходів.

## Емпіричний аналіз

Було протестовано час виконання кожного з алгоритмів на наборах даних різного розміру: 100, 500, 1000, 5000 і 10000 елементів. Для вимірювання часу виконання використовувався модуль `timeit`.

### Результати

Під час тестування було отримано такі результати:

| Розмір вхідного масиву | Час Merge Sort (с) | Час Insertion Sort (с) | Час Timsort (с) |
|------------------------|---------------------|------------------------|-----------------|
| 100                    | 0.000140            | 0.000146               | 0.000005        |
| 500                    | 0.000815            | 0.004397               | 0.000029        |
| 1000                   | 0.001444            | 0.016282               | 0.000066        |
| 5000                   | 0.008645            | 0.440543               | 0.000368        |
| 10000                  | 0.018217            | 1.768367               | 0.000799        |

### Висновки

- **Сортування злиттям** показало стабільний час виконання з теоретичною складністю O(n log n), що робить його ефективним для великих масивів.
- **Сортування вставками** виявилося неефективним для великих наборів даних через квадратичну складність, але може бути корисним для малих або майже відсортованих масивів.
- **Timsort** продемонстрував найкращі результати, завдяки комбінації сортування злиттям і вставками. Він ефективно використовує переваги кожного з цих підходів, що робить його оптимальним вибором для більшості реальних випадків.

Таким чином, поєднання сортування злиттям і сортування вставками робить Timsort набагато ефективнішим, і саме з цієї причини програмісти зазвичай використовують вбудовані алгоритми сортування Python, а не кодують власні. Це підтверджує вибір Python на користь Timsort як алгоритму сортування за замовчуванням.

